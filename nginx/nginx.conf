# ============================================================================
# Nginx Reverse Proxy Configuration for Django + WebSocket (Daphne/Channels)
# ============================================================================
#
# This config solves three problems:
#
# 1. CSRF MISMATCH: Django sees "Host: web:8000" (Docker internal) instead of
#    the real domain. We fix this with proxy_set_header Host.
#
# 2. WEBSOCKET UPGRADE: HTTP/1.1 by default doesn't support WebSocket. We use
#    the "map" directive to conditionally set Connection: upgrade.
#
# 3. REAL CLIENT IP: Behind a proxy, Django sees the proxy's IP as the client.
#    X-Forwarded-For fixes this (important for logging and fail2ban).
# ============================================================================

events {
    worker_connections 1024;
}

http {
    include       mime.types;
    default_type  application/octet-stream;

    # --------------------------------------------------------------------------
    # WebSocket upgrade mapping
    # --------------------------------------------------------------------------
    # The HTTP Upgrade mechanism is how a browser requests a WebSocket connection.
    # The browser sends "Upgrade: websocket" header. Nginx must forward this AND
    # set "Connection: upgrade" — but only for WebSocket requests. For normal HTTP
    # requests, Connection should be empty (or "keep-alive").
    #
    # This map directive checks the Upgrade header:
    #   - If present (e.g., "websocket") -> set $connection_upgrade to "upgrade"
    #   - If absent (normal HTTP)        -> set $connection_upgrade to "" (close)
    map $http_upgrade $connection_upgrade {
        default upgrade;
        ""      close;
    }

    sendfile    on;
    tcp_nopush  on;

    # ------------------------------------------------------------------
    # Access log format with real client IP
    # ------------------------------------------------------------------
    # $http_x_forwarded_for contains the REAL client IP when behind
    # Ngrok or another upstream proxy. Without this, all requests appear
    # to come from 127.0.0.1 or the Docker network gateway.
    #
    # If you use fail2ban, configure it to parse this log format and
    # extract the IP from X-Forwarded-For, NOT from $remote_addr.
    log_format proxy_log '$remote_addr - $remote_user [$time_local] '
                         '"$request" $status $body_bytes_sent '
                         '"$http_referer" "$http_user_agent" '
                         'xff="$http_x_forwarded_for"';

    access_log /var/log/nginx/access.log proxy_log;

    upstream django {
        server web:8000;
    }

    server {
        listen 80;
        server_name _;

        # --------------------------------------------------------------
        # Custom error pages — served when Django/Daphne is unreachable
        # --------------------------------------------------------------
        error_page 502 /errors/502.html;
        error_page 503 /errors/503.html;

        location ^~ /errors/ {
            internal;
            alias /usr/share/nginx/errors/;
        }

        # --------------------------------------------------------------
        # Static files — served directly by Nginx (bypass Django)
        # --------------------------------------------------------------
        location /static/ {
            alias /app/staticfiles/;
            expires 30d;
            add_header Cache-Control "public, immutable";
        }

        # --------------------------------------------------------------
        # All other requests — proxy to Django/Daphne
        # --------------------------------------------------------------
        location / {
            proxy_pass http://django;

            # ---- CRITICAL HEADER: Host ----
            # $http_host = the Host header the browser sent (e.g., "faeries.ngrok.app")
            # Without this, Django sees "Host: web:8000" and CSRF fails because
            # it doesn't match the Origin header ("https://faeries.ngrok.app").
            proxy_set_header Host $http_host;

            # ---- CRITICAL HEADER: X-Forwarded-Proto ----
            # Tells Django what protocol the client actually used.
            # Combined with SECURE_PROXY_SSL_HEADER in settings.py, this makes
            # Django treat the request as HTTPS even though Nginx->Django is HTTP.
            proxy_set_header X-Forwarded-Proto $scheme;

            # ---- CRITICAL HEADER: X-Forwarded-For ----
            # The real client IP. Without this, Django's REMOTE_ADDR is the
            # Docker gateway IP (172.x.x.1), which breaks rate limiting,
            # fail2ban, and any IP-based logic.
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

            # ---- WebSocket support ----
            # HTTP/1.1 is required for the Upgrade mechanism.
            # The Upgrade and Connection headers are set from the map above.
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection $connection_upgrade;

            # ---- WebSocket timeout ----
            # Default proxy_read_timeout is 60s, which would close idle
            # WebSocket connections after 1 minute. Set to 24 hours.
            proxy_read_timeout 86400s;
            proxy_send_timeout 86400s;
        }
    }
}
